<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>js基础知识点总结</title>
  <script>
    //1 js的书写位置：内嵌 外链 行内
    //2 变量
    //  作用：存储数据,对数据进行复用
    //  声明方式：var 变量名;
    //  赋值：弱类型  var num;   num = 200;   num = "abc"（不推荐）;
    //  初始化:var num = 100;
    
    
    //  添加内容: 赋值表达式的返回值为赋值的那个值
    //  赋值表达式  初始化语句
    //var num;
    //console.log(num = 200);
    //console.log(var num3 = 100);
    
    //3 基本数据类型：number string boolean null undefined
    //4 检测方式： typeof
    
    //5 转换
    //  5.1 转换为字符串类型:
    //      数据.toString()  String(数据)    数据 + ""
    
    //   5.2 转换为数值类型:
    //      Number(数据);  parseInt("100.1a");  parseFloat();   +数据  数据-0   */%
    
    //   5.3 转为为布尔类型：
    //      Boolean(数据)  !!数据
    //      转换为false的结果： false NaN 0 undefined null ""
    
    //6 undefined与null
    // undefined的出现场景：
    //    1 变量声明未赋值
    //    2 数组中的元素不存在，值为undefined
    //    3 函数的形参未获取到对应的实参值(与情况1相同)
    //    4 函数没设置返回值，默认为undefined
    //    5 对象的属性不存在，值为undefined(情况2与此条相同)
    
    // null通过typeof检测时，值为"object"不准确
    // null表示空，代表了对象创建前的一种状态
    // null内部保存的值是一个空指针，这个空指针就是null的实际值，所以是基本数据类型
    
    //console.log(Object.prototype.toString.call(null));//"[object Null]";
    
    //var sum = 0;
    //var str = "";
    //var arr = [];
    //var obj = null;
    
    //7 运算符
    //算数运算符: +-*/%
    //一元运算符: ! ++ --
    //      ++和--在单独使用时，前置后置没区别
    //      如果++和--与其他运算结合使用，根据前后置不同，当前取值结果也不同(注意，只影响当前位置的取值)
    
    //比較运算符：  均返回布尔值
    //      > < >= <=
    //      == === != !== 相等比較值，全等比較值和类型。
    //      null == undefined //true     NaN跟任意数据进行比較均为false isNaN(NaN);
    
    //逻辑运算符：
    //  &&  两个操作数均为true，结果为true
    //  ||  两个操作数均为false，结果为false
    //  !   取反
    
    //当操作数不是布尔值时，执行短路操作(逻辑中断)
    //1 从左往右看
    //2 如果不是布尔值，隐式转换为布尔值
    //3 哪个操作数可以决定式子的结果，返回这个原操作数
    
    
    //赋值运算符：
    // = += -= *= /= %=
    
    //三元运算符：  条件?式子1:式子2;
    
    //运算符的优先级：
    //()
    //一元运算符:
    //算数运算符: 先*/% 后+-
    //比較：先>< >= <=  后== === != !==
    //逻辑运算符: 先&& 后||
    //三元运算符：
    //赋值运算符：
    
    
    //流程控制：
    //顺序结构:默认的执行结构
    //分支结构:
    //    使用场景：当程序的执行出现了多种情况
    //    if语句：适用于范围的比較
    //    三种使用形式：
    
    //    switch语句：适用于单值的比較
    //    一个case执行完后，会继续执行下一个case的代码，如果不需要，记得书写break;
    //    如果进行范围比較，条件中书写true即可。
    
    //    三元运算符：
    //    2>1?alert("2大"):alert("1大");
    //    2>1?parseInt("2"):parseInt("1");
    
    //循环结构:
    //    使用场景：单纯的需要在一个位置将代码重复执行n次
    //    for(;;){}
    //    for循环更适用于:确定次数的重复执行代码
    
    //    while(){}
    //    while循环适用于:重复执行次数不定
    
    //    do..while();
    //    先执行代码一次，然后在判断
    
    //break和continue：
    //break：跳出循环，跳出switch
    //continue: 结束本次循环，进行下一次循环执行
    
    
    //数组：
    //1 声明
    //    var arr = [];  var arr = new Array();
    
    //2 数组的长度属性
    //    表示元素的个数，数值类型。 设置的length的值小于元素个数，可以删除一部分元素，还可以清空数组
    //    arr = [];   arr.length = 0;
    
    //3 索引值:
    //    数组的元素按照索引排列，索引从0开始
    //    利用索引值可以对元素进行具体操作：  arr[5]   arr["6"]
    
    //4 索引和长度的关系：
    //    数组最后一项的索引值：  arr.length-1   arr[arr.length-1];
    //    数组的新项的索引值：    arr.length     arr[arr.length]
    
    //5 操作方式：正向遍历  反向遍历
    
    //6 类型检测：
    //    Array.isArray(数据)   数据 instanceof Array;  Object.prototype.toString.call(数据)
    
    
    //7 基本数据类型和复杂数据类型的区别：
    //  保存数据的个数不同
    //  在内存中保存方式不同：基本类型在内存单元中保存的是具体值，复杂类型在内存单元中保存的是具体值的指针。
    //      基本类型又称为值类型，复杂类型有称为引用类型
    //  复制后的结果不同：
    
    
    //函数：
    //1 函数的作用：重用，提高代码利用率，增强代码的灵活性.
    //2 声明方式：  函数声明语句 function fun(){}  函数表达式 var fun = function(){};
    //3 调用：函数的代码需要调用才能执行。 函数名();
    
    //4 参数：
    //   函数整体功能一定，内部一些值不确定，可以使用参数.
    //   分类：形参  实参
    
    //5 返回值：
    //   必然性：想要在函数外得到函数计算的结果，必须使用返回值.
    //   设置方式： return 值;
    //   接收方式： 调用表达式本身就是返回值。
    //   return的第二个作用：跳出函数
    
    //6 作用域：
    //  全局作用域，局部作用域。
    //  全局变量，局部变量
    
    //  作用域链的访问规则：
    
    //7 预解析：
    //    1 查找当前作用域中的var变量声明语句，将声明提升到当前作用域顶端，赋值保留在原地
    //    2 找function函数声明语句，函数体整体提升，调用保留在原地。
    //    以上两步部分先后
    
    //8 重名
    //  js中的函数不允许重名，后者覆盖前者
    //  arguments 只能在函数内使用，内部保存了本次调用的所有实参
    //  arguments 是伪数组(类数组)形式,只有数组的结构，没有数组方法
    //  arguments 可以模拟函数重载
    
    //  变量和函数不能重名，如果重名，取值取决于变量，变量有值取变量值，变量没值取函数值
    
    //9 类型 "function"  使用typeof检测
    
    //10 匿名函数的使用
    //   1 保存在变量中作为函数表达式使用
    //   2 自调用函数（立即执行函数）  (function(){})();
    //      作用：包裹作用域，减少全局变量的使用，降低命名难度
    
    //   3 回调函数：将匿名函数作为参数使用
    //       使用场景：当函数整体功能一定，但是内部的某些子功能不确定时，需要使用回调函数
    
    
    //对象：
    //1 创建：  var obj = new Object()  var obj = {name:"张三",age:18};
    //2 属性和方法:  对象.属性名 = 属性值;   方法也是属性，只不过保存的是函数值
    //  属性访问的两种方式：  对象["属性名"] = 属性值;
    
    //3 构造函数的使用:
    //    1 命名首字母大写
    //    2 调用前加new
    //    3 使用this添加属性方法
    
    //4 new的作用：
    //    1 创建对象
    //    2 返回对象
    //    3 更改this的指向
    
    //5 this的使用:
    //    使用场景：只有在方法中使用才有意义
    //    1 基本使用：指向函数调用者(这个方法属于谁)
    //    2 特殊使用：new更改了指向
    
    //6 forin
    //for (var k in obj) {
    //k - 属性名 - 字符串
    //obj[k] - 属性值
    //}
    
    //7 JSON
    //  写法：与对象字面量几乎相同，属性名需要加双引号
  
  
  </script>
</head>
<body>


</body>
</html>